---
title: "Exploratory Data Analysis"
author: "Choonghyun Ryu"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Exploratory Data Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r environment, echo = FALSE, message = FALSE, warning=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "", out.width = "600px", dpi = 70)
options(tibble.print_min = 4L, tibble.print_max = 4L)

library(dlookr)
library(dplyr)
library(ggplot2)
```

## Preface
After you have acquired the data, you should do the following:

* Diagnose data quality.
    + If there is a problem with data quality,
    + The data must be corrected or re-acquired.
* **Explore data to understand the data and find scenarios for performing the analysis.**
* Derive new variables or perform variable transformations.

The dlookr package makes these steps fast and easy:

* Performs an data diagnosis or automatically generates a data diagnosis report.
* **Discover data in a variety of ways, and automatically generate EDA(exploratory data analysis) report.**
* Impute missing values and outliers, resolve skewed data, and categorize continuous variables into categorical variables. And generates an automated report to support it.

This document introduces **EDA(Exploratory Data Analysis)** methods provided by the dlookr package. You will learn how to EDA of `tbl_df` data that inherits from data.frame and `data.frame` with functions provided by dlookr.

dlookr increases synergy with `dplyr`. Particularly in data exploration and data wrangle, it increases the efficiency of the `tidyverse` package group.

## Supported data structures
Data diagnosis supports the following data structures.

* data frame : data.frame class.
* data table : tbl_df class.
* **table of DBMS** : table of the DBMS through tbl_dbi.
  + **Use dplyr as the back-end interface for any DBI-compatible database.**
  
## datasets
To illustrate the basic use of EDA in the dlookr package, I use a `medicost` dataset.
`medicost` in the `dlookr` package is a dataset containing the age and other attributes of almost 1400 cases. This data is a data.frame created for the purpose of predicting medical costs billed by health insurance.

```{r import_data, warning=FALSE}
str(medicost)
```

The contents of individual variables are as follows.

* age
    + age of primary beneficiary.
* sex
    + insurance contractor gender, female, male.
* bmi
    + body mass index, providing an understanding of body, weights that are relatively high or low relative to height, objective index of body weight (kg / m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9.
* children
    + number of children covered by health insurance / Number of dependents.
* smoker
    + flag of smoking, yes, no.
* region
    + the beneficiary's residential area in the US, northeast, southeast, southwest, northwest.
* charges
    + individual medical costs billed by health insurance.

When data analysis is performed, data containing missing values is frequently encountered. However, 'medicost' is complete data without missing values. So the following script created the missing values and saved them as `medicosts`.

```{r missing}
medicosts <- medicost

suppressWarnings(RNGversion("3.5.0"))
set.seed(123)
medicosts[sample(seq(NROW(medicosts)), 20), "bmi"] <- NA

suppressWarnings(RNGversion("3.5.0"))
set.seed(456)
medicosts[sample(seq(NROW(medicosts)), 10), "smoker"] <- NA
```

## Exploratory Data Analysis
dlookr can help to understand the distribution of data by calculating descriptive statistics of numerical data. In addition, correlation between variables is identified and normality test is performed. It also identifies the relationship between target variables and independent variables.:

The following is a list of the EDA functions included in the dlookr package.:

* `describe()` provides descriptive statistics for numerical data.
* `normality()` and `plot_normality()` perform normalization and visualization of numerical data.
* `correlate()` and `plot.correlate()` calculate the correlation coefficient between two numerical data and provide visualization.
* `target_by()` defines the target variable and `relate()` describes the relationship with the variables of interest corresponding to the target variable.
* `plot.relate()` visualizes the relationship to the variable of interest corresponding to the destination variable.
* `eda_report()` performs an exploratory data analysis and reports the results.

## Univariate data EDA
### Calculating descriptive statistics using `describe()`

`describe()` computes descriptive statistics for numerical data. The descriptive statistics help determine the distribution of numerical variables. Like function of dplyr, the first argument is the tibble (or data frame). The second and subsequent arguments refer to variables within that data frame.

The variables of the `tbl_df` object returned by `describe()` are as follows.

* `n` : number of observations excluding missing values
* `na` : number of missing values
* `mean` : arithmetic average
* `sd` : standard deviation
* `se_mean` : standard error mean. sd/sqrt(n)
* `IQR` : interquartile range (Q3-Q1)
* `skewness` : skewness
* `kurtosis` : kurtosis
* `p25` : Q1. 25% percentile
* `p50` : median. 50% percentile
* `p75` : Q3. 75% percentile
* `p01`, `p05`, `p10`, `p20`, `p30` : 1%, 5%, 20%, 30% percentiles
* `p40`, `p60`, `p70`, `p80` : 40%, 60%, 70%, 80% percentiles
* `p90`, `p95`, `p99`, `p100` : 90%, 95%, 99%, 100% percentiles

For example, `describe()` can computes the statistics of all numerical variables in `medicosts`:

```{r describe}
describe(medicosts)
```

* `skewness` : The left-skewed distribution data that is the variables with large positive skewness should consider the log or sqrt transformations to follow the normal distribution. The variables `charges` seem to need to consider variable transformation.
* `mean` and `sd`, `se_mean` : The` charges` with a large `standard error of the mean`(se_mean) has low representativeness of the `arithmetic mean`(mean). The `standard deviation`(sd) is much larger than the arithmetic average.

The following explains the descriptive statistics only for a few selected variables.:

```{r describes2}
# Select columns by name
describe(medicosts, bmi, children, charges)
# Select all columns between year and day (include)
describe(medicosts, bmi:charges)
# Select all columns except those from year to day (exclude)
describe(medicosts, -(bmi:charges))
```

The `describe()` function can be sorted by `left or right skewed size`(skewness) using `dplyr`.:

```{r describe_pipe}
medicosts %>%
  describe() %>%
  select(described_variables, skewness, mean, p25, p50, p75) %>% 
  filter(!is.na(skewness)) %>% 
  arrange(desc(abs(skewness)))
```

The `describe()` function supports the `group_by()` function syntax of the `dplyr` package.

```{r describe_pipe2}
medicosts %>%
  group_by(sex) %>% 
  describe(bmi, charges) 
```

```{r describe_pipe3}
medicosts %>%
  group_by(sex, smoker) %>% 
  describe(bmi, charges) 
```

### Test of normality on numeric variables using `normality()`
`normality()` performs a normality test on numerical data. `Shapiro-Wilk normality test` is performed. When the number of observations is greater than 5000, it is tested after extracting 5000 samples by random simple sampling.

The variables of `tbl_df` object returned by `normality()` are as follows.

* `statistic` : Statistics of the Shapiro-Wilk test
* `p_value` : p-value of the Shapiro-Wilk test
* `sample` : Number of sample observations performed Shapiro-Wilk test

`normality()` performs the normality test for all numerical variables of `medicosts` as follows.:

```{r normality}
normality(medicosts)
```

The following example performs a normality test on only a few selected variables.

```{r normality2}
# Select columns by name
normality(medicosts, bmi, children, charges)

# Select all columns between year and day (inclusive)
normality(medicosts, bmi:charges)

# Select all columns except those from year to day (inclusive)
normality(medicosts, -(bmi:charges))
```

You can use `dplyr` to sort variables that do not follow a normal distribution in order of `p_value`:

```{r normality_pipe}
library(dplyr)

medicosts %>%
  normality() %>%
  filter(p_value <= 0.01) %>% 
  arrange(abs(p_value))
```

In particular, the `charges` variable is considered to be the most out of the normal distribution.

The `normality()` function supports the `group_by()` function syntax in the `dplyr` package.

```{r normality_pipe2}
medicosts %>%
  filter(!is.na(smoker)) %>% 
  group_by(sex, smoker) %>%
  normality(bmi) %>% 
  arrange(desc(p_value))
```

The `bmi` variable is not normally distributed. However, if `sex` is `male` and `smoker` is `yes`, or `sex` is `female` and `smoker` is `no`, normal distribution is followed at the significance level of 0.05.

The following example performs `normality test of log(bmi)` for each combination of `sex` and `smoker` categorical variables to search for variables that follow the normal distribution.

```{r normality_pipe3}
medicosts %>%
  filter(!is.na(smoker)) %>%   
  mutate(log_bmi = log(bmi)) %>%
  group_by(sex, smoker) %>%
  normality(log_bmi) %>%
  filter(p_value > 0.05)
```


### Visualization of normality of numerical variables using `plot_normality()`
`plot_normality()` visualizes the normality of numeric data.

The information visualized by `plot_normality()` is as follows.:

* `Histogram of original data`
* `Q-Q plot of original data`
* `histogram of log transformed data`
* `Histogram of square root transformed data`

In the data analysis process, it often encounters numerical data that follows the `power-law distribution`. Since the numerical data that follows the `power-law distribution` is converted into a normal distribution by performing the `log` or `sqrt` transformation, so draw a histogram of the `log` and `sqrt` transformed data.

`plot_normality()` can also specify several variables like `normality()` function.

```{r plot_normality, fig.align='center', fig.width = 7, fig.height = 5}
# Select columns by name
plot_normality(medicosts, bmi, charges)
```

The `plot_normality()` function also supports the `group_by()` function syntax in the `dplyr` package.

```{r plot_normality2, fig.align='center', fig.width = 7, fig.height = 5, eval=FALSE}
medicosts %>%
  filter(sex == "male") %>%
  group_by(smoker) %>%
  plot_normality(charges)
```


## EDA of bivariate data
### Calculation of `correlation coefficient` using `correlate()`

`correlate()` calculates the correlation coefficient of all combinations of `medicosts` numerical variables as follows:

```{r correlate}
correlate(medicosts)
```

The following example performs a normality test only on combinations that include several selected variables.

```{r correlate2}
# Select columns by name
correlate(medicosts, bmi, children, charges)

# Select all columns between year and day (include)
correlate(medicosts, bmi:charges)

# Select all columns except those from year to day (exclude)
correlate(medicosts, -(bmi:charges))
```

`correlate()` produces `two pairs of variables`. So the following example uses `filter()` to get the correlation coefficient for `a pair of variable` combinations:


```{r correlate3}
medicosts %>%
  correlate(bmi:charges) %>%
  filter(as.integer(var1) > as.integer(var2))
```

The `correlate()` also supports the `group_by()` function syntax in the `dplyr` package.

```{r correlate4}
tab_corr <- medicosts %>%
  filter(region == "northwest") %>%
  group_by(sex, smoker) %>%
  correlate(charges) %>%
  filter(abs(coef_corr) > 0.5)

tab_corr
```


### Visualization of the correlation matrix using `plot.correlate()`
`plot.correlate()` visualizes the correlation matrix with correlate class.

```{r plot_correlate, fig.align='center', fig.width = 7, fig.height = 5}
medicosts %>% 
  correlate() %>% 
  plot()
```

`plot.correlate()` can also specify multiple variables, like the `correlate()` function.
The following is a visualization of the correlation matrix including several selected variables.

```{r plot_correlate2, fig.align='center', fig.width = 6, fig.height = 4, eval=TRUE}
# Select columns by name
correlate(medicosts, bmi, charges) %>% 
  plot()
```

The `plot.correlate()` function also supports the `group_by()` function syntax in the `dplyr` package.

```{r plot_correlate3, fig.align='center', fig.width = 6, fig.height = 4, warning=FALSE, eval=TRUE}
medicosts %>%
  filter(region == "northwest") %>%
  group_by(smoker) %>%
  correlate() %>%
  plot() 
```


## EDA based on target variable

### Definition of target variable
To perform EDA based on `target variable`, you need to create a `target_by` class object.
`target_by()` creates a `target_by` class with an object inheriting data.frame or data.frame. `target_by()` is similar to `group_by()` in `dplyr` which creates `grouped_df`. The difference is that you specify only one variable.

The following is an example of specifying `smoker` as target variable in `medicosts` data.frame.:

```{r target_by}
categ <- target_by(medicosts, smoker)
```

### EDA when target variable is categorical variable

Let's perform EDA when the target variable is a categorical variable. When the categorical variable `smoker` is the target variable, we examine the relationship between the target variable and the predictor.

#### Cases where predictors are numeric variable
`relate()` shows the relationship between the target variable and the predictor. The following example shows the relationship between `charges` and the target variable `smoker`. The predictor `charges` is a numeric variable. In this case, the descriptive statistics are shown for each level of the target variable.

```{r target_by2}
# If the variable of interest is a numerical variable
cat_num <- relate(categ, charges)
cat_num
summary(cat_num)
```

`plot()` visualizes the `relate` class object created by `relate()` as the relationship between the target variable and the predictor variable. The relationship between `smoker` and `charges` is visualized by density plot.

```{r target_by3, fig.align='center', fig.width = 7, fig.height = 5, warning=FALSE}
plot(cat_num)
```

#### Cases where predictors are categorical variable

The following example shows the relationship between `ShelveLoc` and the target variable `smoker`. The predictor variable `sex` is a categorical variable. In this case, it shows the `contingency table` of two variables. The `summary()` function performs `independence test` on the contingency table.

```{r target_by4}
# If the variable of interest is a categorical variable
cat_cat <- relate(categ, sex)
cat_cat
summary(cat_cat)
```

`plot()` visualizes the relationship between the target variable and the predictor. The relationship between `smoker` and `sex` is represented by a `mosaics plot`.

```{r target_by5, fig.align='center', fig.width = 7, fig.height = 5, warning=FALSE}
plot(cat_cat)
```

### EDA when target variable is numerical variable
Let's perform EDA when the target variable is numeric. When the numeric variable `charges` is the target variable, we examine the relationship between the target variable and the predictor.

```{r target_by6}
# If the variable of interest is a numerical variable
num <- medicosts %>% 
  filter(!is.na(bmi)) %>% 
  target_by(charges)
```

#### Cases where predictors are numeric variable

The following example shows the relationship between `bmi` and the target variable `charges`. The predictor variable `bmi` is a numeric variable. In this case, it shows the result of a `simple linear model` of the `target ~ predictor` formula. The `summary()` function expresses the details of the model.

```{r target_by7}
# If the variable of interest is a numerical variable
num_num <- relate(num, bmi)
num_num
summary(num_num)
```

`plot()` visualizes the relationship between the target and predictor variables. The relationship between `charges` and `bmi` is visualized with a scatter plot. 
The figure on the left shows the scatter plot of `charges` and `bmi` and the confidence interval of the regression line and regression line. 
The figure on the right shows the relationship between the original data and the predicted values of the linear model as a scatter plot. If there is a linear relationship between the two variables, the scatter plot of the observations converges on the red diagonal line.

```{r target_by8, fig.align='center', fig.width = 7, fig.height = 5, warning=FALSE}
plot(num_num)
```

The scatter plot of the data with a large number of observations is output as overlapping points. This makes it difficult to judge the relationship between the two variables. It also takes a long time to perform the visualization.
In this case, the above problem can be solved by `hexabin plot`.

In `plot()`, the `hex_thres` argument provides a basis for drawing `hexabin plot`. If the number of observations is greater than `hex_thres`, draw a `hexabin plot`.

The following example visualizes the `hexabin plot` rather than the scatter plot by specifying 350 for the `hex_thres` argument. This is because the number of observations is 400.

```{r target_by8_2, fig.align='center', fig.width = 7, fig.height = 5, warning=FALSE}
plot(num_num, hex_thres = 350)
```

#### Cases where predictors are categorical variable

The following example shows the relationship between `smoker` and the target variable `charges`. The predictor `smoker` is a categorical variable and shows the result of `one-way ANOVA` of `target ~ predictor` relationship. The results are expressed in terms of ANOVA.
The `summary()` function shows the `regression coefficients` for each level of the predictor. In other words, it shows detailed information about `simple regression analysis` of `target ~ predictor` relationship.


```{r target_by9}
# If the variable of interest is a categorical variable
num_cat <- relate(num, smoker)
num_cat
summary(num_cat)
```

`plot()` visualizes the relationship between the target variable and the predictor. The relationship between `Sales` and `ShelveLoc` is represented by a `box plot`.

```{r target_by10, fig.align='center', fig.width = 7, fig.height = 5, warning=FALSE}
plot(num_cat)
```


## Automated report

dlookr provides two automated EDA reports:

* Web page-based dynamic reports can perform in-depth analysis through visualization and statistical tables.
* Static reports generated as pdf files or html files can be archived as output of data analysis.

### Create a dynamic report using `eda_web_report()`
`eda_web_report()` create dynamic report for object inherited from data.frame(`tbl_df`, `tbl`, etc) or data.frame.

#### Contents of dynamic web report
The contents of the report are as follows.:

* Overview
    + Data Structures
    + Data Types
    + Job Informations
* Univariate Analysis
    + Descriptive Statistics
    + Normality Test
* Bivariate Analysis
    + Compare Numerical Variables
    + Compare Categorical Variables
* Multivariate Analysis
    + Correlation Analysis
        + Correlation Matrix
        + Correlation Plot
* Target based Analysis
    + Grouped Numerical Variables
    + Grouped Categorical Variables
    + Grouped Correlation

#### Some arguments for dynamic web report
eda_web_report() generates various reports with the following arguments.

* target
    + target variable
* output_file
    + name of generated file.
* output_dir
    + name of directory to generate report file.
* title
    + title of report. 
* subtitle
    + subtitle of report. 
* author
    + author of report. 
* title_color
    + color of title.
* logo_img
    + name of logo image file on top left.
* create_date
    + The date on which the report is generated.
* theme
    + name of theme for report. support "orange" and "blue". 
* sample_percent
    + Sample percent of data for performing EDA.


The following script creates a EDA report for the `data.frame` class object, `heartfailure`.

```{r eda_web_report, eval=FALSE}
heartfailure %>%
  eda_web_report(target = "death_event", subtitle = "heartfailure", 
                 output_dir = "./", output_file = "EDA.html", theme = "blue")
```

#### Screenshot of dynamic report

* The dynamic contents of the report is shown in the following figure.:

```{r eda_web_title, echo=FALSE, out.width='80%', fig.align='center', fig.pos="!h", fig.cap="The part of the report"}
knitr::include_graphics('img/eda_web_title.jpg')
```

### Create a EDA report using `eda_paged_report()`
`eda_paged_report()` create static report for object inherited from data.frame(`tbl_df`, `tbl`, etc) or data.frame.

#### Contents of static paged report
The contents of the report are as follows.:

* Overview
    + Data Structures
    + Job Informations
* Univariate Analysis
    + Descriptive Statistics
        + Numerical Variables
        + Categorical Variables
    + Normality Test    
* Bivariate Analysis
    + Compare Numerical Variables
    + Compare Categorical Variables
* Multivariate Analysis  
    + Correlation Analysis
        + Correlation Coefficient Matrix
        + Correlation Plot
* Target based Analysis
    + Grouped Numerical Variables
    + Grouped Categorical Variables
    + Grouped Correlation

#### Some arguments for static paged report
eda_paged_report() generates various reports with the following arguments.

* target
    + target variable
* output_format
    + report output type. Choose either "pdf" and "html".
* output_file
    + name of generated file.
* output_dir
    + name of directory to generate report file.
* title
    + title of report. 
* subtitle
    + subtitle of report. 
* abstract_title
    + abstract of report
* author
    + author of report. 
* title_color
    + color of title.
* subtitle_color
    + color of subtitle.
* logo_img
    + name of logo image file on top left.
* cover_img
    + name of cover image file on center.
* create_date
    + The date on which the report is generated.
* theme
    + name of theme for report. support "orange" and "blue". 
* sample_percent
    + Sample percent of data for performing EDA.

The following script creates a EDA report for the `data.frame` class object, `heartfailure`.

```{r eda_paged_report, eval=FALSE}
heartfailure %>%
  eda_paged_report(target = "death_event", subtitle = "heartfailure", 
                   output_dir = "./", output_file = "EDA.pdf", theme = "blue")
```

#### Screenshot of static report

* The cover of the report is shown in the following figure.:

```{r eda_paged_cover, echo=FALSE, out.width='80%', fig.align='center', fig.pos="!h", fig.cap="The part of the report"}
knitr::include_graphics('img/eda_paged_cover.jpg')
```

* The contents of the report is shown in the following figure.:

```{r eda_paged_cntent, echo=FALSE, out.width='80%', fig.align='center', fig.pos="!h", fig.cap="The dynamic contents of the report"}
knitr::include_graphics('img/eda_paged_content.jpg')
```


## Exploratory data analysis for tables in DBMS

EDA function for table of DBMS supports In-database mode that performs SQL operations on the DBMS side. If the size of the data is large, using In-database mode is faster.

It is difficult to obtain anomaly or to implement the sampling-based algorithm in SQL of DBMS. So some functions do not yet support In-database mode. In this case, it is performed in In-memory mode in which table data is brought to R side and calculated.
In this case, if the data size is large, the execution speed may be slow. It supports the collect_size argument, which allows you to import the specified number of samples of data into R.

* In-database support functions
    + none
* In-database not support functions
    + `normality()`
    + `plot_normality()`    
    + `correlate()`  
    + `plot.correlate()`
    + `describe()`
    + `eda_web_report()`
    + `eda_paged_report()`
    
### Preparing table data

Copy the `medicosts` data frame to the SQLite DBMS and create it as a table named `TB_MEDICOST`.
Mysql/MariaDB, PostgreSQL, Oracle DBMS, other DBMS are also available for your environment. 

```{r dbi_table, warning=FALSE, message=FALSE, eval=FALSE}
if (!require(DBI)) install.packages('DBI', repos = "http://cran.us.r-project.org")
if (!require(RSQLite)) install.packages('RSQLite', repos = "http://cran.us.r-project.org")
if (!require(dplyr)) install.packages('dplyr', repos = "http://cran.us.r-project.org")
if (!require(dbplyr)) install.packages('dbplyr', repos = "http://cran.us.r-project.org")

library(dplyr)

medicosts <- medicost

# connect DBMS
con_sqlite <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")

# copy medicosts to the DBMS with a table named TB_MEDICOST
copy_to(con_sqlite, medicosts, name = "TB_MEDICOST", overwrite = TRUE)
```

### Calculating descriptive statistics of numerical column of table in the DBMS

Use `dplyr::tbl()` to create a tbl_dbi object, then use it as a data frame object. That is, the data argument of all EDA function is specified as tbl_dbi object instead of data frame object.


```{r dbi_describe, eval=FALSE}
# Positive values select variables
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  describe(age, bmi, charges)

# Negative values to drop variables, and In-memory mode and collect size is 200
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  describe(-age, -bmi, -charges, collect_size = 200)

# Find the statistic of all numerical variables by 'sex' and 'smoker',
# and extract only those with 'sex' variable level is "male".
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  group_by(sex, smoker) %>%
  describe() %>%
  filter(sex == "male")

# extract only those with 'region' variable level is "northwest",
# and find 'charges' statistics by 'sex' and 'smoker'
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  filter(region == "northwest") %>%
  group_by(sex, smoker) %>%
  describe(charges)
```

### Test of normality on numeric columns using in the DBMS

```{r dbi_normality, eval=FALSE}
# Test all numerical variables by 'sex' and 'smoker',
# and extract only those with 'sex' variable level is "male".
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  group_by(sex, smoker) %>%
  normality() %>%
  filter(sex == "male")

# extract only those with 'region' variable level is "northwest",
# and test 'charges' by 'sex' and 'smoker'
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  filter(region == "northwest") %>%
  group_by(sex, smoker) %>%
  normality(charges)

# Test log(charges) variables by 'sex' and 'smoker',
# and extract only p.value greater than 0.01.

# SQLite extension functions for log transformation
RSQLite::initExtension(con_sqlite)

con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  mutate(log_charges = log(charges)) %>%
  group_by(sex, smoker) %>%
  normality(log_charges) %>%
  filter(p_value < 0.01)
```

### Normalization visualization of numerical column in the DBMS

```{r plot_normality_dbi, fig.align='center', fig.width = 6, fig.height = 4, eval=FALSE}
# extract only those with 'sex' variable level is "male",
# and plot 'charges' by 'smoker'
# the result is same as a data.frame, but not display here. reference above in document.
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  filter(sex == "male") %>%
  group_by(smoker) %>%
  plot_normality(charges)
```

### Compute the correlation coefficient between two columns of table in DBMS
```{r dbi_correlation, eval=FALSE}
# Correlation coefficient
# that eliminates redundant combination of variables
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  correlate() %>%
  filter(as.integer(var1) > as.integer(var2))

con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  correlate(bmi, charges) %>%
  filter(as.integer(var1) > as.integer(var2))

# Compute the correlation coefficient of charges variable by 'sex'
# and 'smoker' variables. And extract only those with absolute
# value of correlation coefficient is greater than 0.5
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  group_by(sex, smoker) %>%
  correlate(charges) %>%
  filter(abs(coef_corr) >= 0.5)

# extract only those with 'region' variable level is "southeast",
# and compute the correlation coefficient of 'charges' variable
# by 'sex' and 'smoker' variables.
# And the correlation coefficient is negative and smaller than 0.3
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  filter(region == "southeast") %>%
  group_by(sex, smoker) %>%
  correlate(charges) %>%
  filter(coef_corr < 0) %>%
  filter(abs(coef_corr) > 0.5)
```

### Visualize correlation plot of numerical columns in the DBMS

```{r plot_correlation_dbi, fig.align='center', fig.width = 6, fig.height = 4, warning=FALSE, eval=FALSE}
# Extract only those with 'region' variable level is "southeast",
# and visualize correlation plot by 'sex' and 'smoker' variables.
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  filter(region == "southeast") %>%
  group_by(sex, smoker) %>%
  correlate() %>% 
  plot()
```

### EDA based on target variable
The following is an EDA where the target column is character and the predictor column is a numeric type.

```{r dbi_ctarget_by, eval=FALSE}
# If the target variable is a categorical variable
categ <- target_by(con_sqlite %>% tbl("TB_MEDICOST") , sex)

# If the variable of interest is a numerical variable
cat_num <- relate(categ, charges)
cat_num
summary(cat_num)
```

```{r plot_target_by_dbi, fig.align='center', fig.align='center', fig.width = 6, fig.height = 4, eval=FALSE}
# the result is same as a data.frame, but not display here. reference above in document.
plot(cat_num)
```

### Reporting the information of EDA for table of the DBMS
The following shows several examples of creating an EDA report for a DBMS table.

Using the `collect_size` argument, you can perform EDA with the corresponding number of sample data.
If the number of data is very large, use `collect_size`.

```{r dbi_eda_report, eval=FALSE, eval=FALSE}
# create web report file. 
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  eda_web_report()
  
# create pdf file. file name is EDA.pdf, and collect size is 350
con_sqlite %>% 
  tbl("TB_MEDICOST") %>% 
  eda_paged_report(collect_size = 350, output_file = "EDA.pdf")
```


